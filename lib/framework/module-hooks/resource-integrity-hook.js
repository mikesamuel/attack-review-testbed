/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview
 * A factory for hooks that prevent require of files not on a production whitelist
 * such as that generated by scripts/generate-production-source-list.js
 */

'use strict';

// eslint-disable-next-line no-use-before-define
exports.makeHook = makeHook;

const {
  createHash,
  Hash: {
    prototype: {
      digest: digestHash,
      update: updateHash,
    },
  },
} = require('crypto');
const { readFileSync } = require('fs');
const { join, relative } = require('path');

const { isBuiltinModuleId } = require('../builtin-module-ids.js');

const { create, hasOwnProperty } = Object;
const { apply } = Reflect;
// eslint-disable-next-line id-blacklist
const { error: consoleerror, warn: consolewarn } = console;

function makeHook(hashesToSourceLists, basedir, reportOnly) {
  const moduleid = relative(basedir, module.filename);
  if (!(hashesToSourceLists && typeof hashesToSourceLists === 'object')) {
    hashesToSourceLists = create(null);
  }

  // Don't hash modules more than once.
  // Assumes that modules don't change on disk.
  const hashCache = new Map();

  function hashFor(file) {
    if (hashCache.has(file)) {
      return hashCache.get(file);
    }

    let key = null;
    let content = null;
    try {
      content = readFileSync(file);
    } catch (exc) {
      consoleerror(`${ moduleid }: ${ exc.message }`);
    }
    if (content !== null) {
      const hash = createHash('sha256');
      key = apply(
        digestHash,
        apply(updateHash, hash, [ content ]),
        [ 'hex' ]);
    }

    hashCache.set(file, key);
    return key;
  }

  return function resourceIntegrityHook(
    importingFile, importingId, requiredId, resolveFilename) {
    if (isBuiltinModuleId(requiredId)) {
      return requiredId;
    }
    let target = null;
    try {
      target = resolveFilename(requiredId);
    } catch (exc) {
      // We fall-through to hash mismatch below.
    }
    if (target !== null) {
      const key = hashFor(target);
      if (key && apply(hasOwnProperty, hashesToSourceLists, [ key ])) {
        return requiredId;
      }
    }

    consolewarn(
      `${ moduleid }: Blocking require(${ JSON.stringify(requiredId) }) by ${ relative(basedir, importingFile) }`);
    if (reportOnly) {
      return requiredId;
    }
    return join(__dirname, 'innocuous.js');
  };
}
